#+title: Intro To Regex
#+index: 8
#+breadcrumbs: index:/index.html
#+source: https://youtu.be/fAgz66M4aNc?si=ybChoNNggXGZmo8U

* Regular expression concepts
A regex is a language describing text to be matched

A regex is composed of:
+ *regular chars* that stand for themselves
+ *metachars* that stand for a regular expression
+ *expressions* denoting categories of chars or sub-parts of a regex

Historically, different tools used different regex "flavors"

POSIX standardizes 2 flavours.
Other tools enhances regexs beyond what we cover here

+ *Basic Regucal Expression (BRE)*
  - simpler to learn, less computationally expensive
+ *Extended Regucal Expression (*ERE)*
  - much more powerful, more expensive
  - on moern systems, no real difference in "expense"

What programs use regex?
+ The =grep= family
  - =grep= - BRE
  - =egrep= and =grep -E= - ERE
  - =fgrep= and =grep -F= - string matching in parallel
  - POSIX standardizing brings them all into the single =grep= command
+ =sed= - text matching and substitution
+ =awk= - pattern matching with programming
+ text editors: =ed=, =ex=, =vim=, =emacs=
+ scripting languages, usually with their on flavours

** =grep= options
+ use =pat= as pattern: =-e pat=
+ read list of patterns from file: =-f file=
+ ignore case in input: =-i=
+ list matching input files: =-l=
+ print lines that don't match: =-v=
+ supress output ("quiet", exit status only): =-q=
  - often, you can use => /dev/null= instead (more obvious)
+ don't print errors ("silent"): =-s=

** Robustness
+ invest time in learning regexs
+ use EREs wherever possible
+ *always quote your regexs on the shell command line*

* Basic regex components
** single char expressions
+ reg chars, like "A" or "#" match themselves
+ case matters: "A" and "a" are different
+ period ("dot") matches any single char
  - may or may not match newline, program dependent
+ escaped metachar:
  - =\.= matches a real period
  - =\\= matches a real backslash

+ reg chars match themselves:
#+begin_src bash
echo 'Hi there how are you' | grep --color 'how'
#+end_src

#+RESULTS:
: Hi there how are you

+ dot matches any single char:
#+begin_src bash
echo tolstoy says im toldtoy | grep --color tol.toy
#+end_src

#+RESULTS:
: tolstoy says im toldtoy

** bracket expressions
+ any one of a set: =[aeiouy]= matches /one/ Englis vowel
+ any not in a set: =[^aieouy]= matches a non-vowel
+ ranges: =[0-9]= -> a digit, =[a-z]= -> a lowercase letter
  - locale dependent (messy)
+ characted classes: digits, punctuation, letters, ...
  - classes: alnum, alpha, blank, cntrl, digit, graph, lower, print, punct, space, upper, digit

+ =grep= matches all ocurrences
#+begin_src bash
echo 123 eafg | grep --color '[aeiouy]'
#+end_src

#+RESULTS:
: 123 eafg

Using =sed= to substitute, matches only the first:
#+begin_src bash
echo 123 eafg | sed 's/[aeiouy]/X/'
#+end_src

#+RESULTS:
: 123 Xafg

Complemented bracket expressions & char classes:
#+begin_src bash :results ouput verbatim
echo 123 eafg | grep --color '[^aeiouy]'
echo 123 eafg | grep --color '[[:digit:]]'
#+end_src

#+RESULTS:
: 123 eafg
: 123 eafg


** repetition - zero or more
Asterisk ("star") indicates zero or more of the preceding char

+ =ab*c= matches =ac=, =abc=, =abbc=,  =abbbc=, ...
+ zero of "x" does not mean one or more of "y"
+ =.*= matches any single char, 0 or more times (careful, *also matches null string*)

** repetition - interval expressions
+ =c\{N\}= - /N/ occurrences of /c/
+ =c\{N,\}= - at least /N/ occurrences of /c/
+ =c\{N, M\}= - /N/ to /M/ occurrences of /c/ (/N/, /M/ up to =RE_DUP_MAX=)

Here /c/ means a single char as described earlier

** achoring maches
+ cared ("up arrow", "hat", =^=) - match must start at beginning of line or string
+ dollar sign (=$=) - match must occur at end of line or string
+ =^= and =$= in the middle of a BRE stand for themselves

#+begin_src bash :results output verbatim
echo 123 you 123 | grep --color '^[[:digit:]]*'

echo 123 you 123 | grep --color '^[^[:digit:]]*'

echo 123 you 123 | grep --color '[^[:digit:]]*$'
#+end_src

#+RESULTS:
: 123 you 123
: 123 you 123

** parenthasized subexpressions
+ =\(a[bc\)\(123\)xx\2\1= - same as =a[bc]123xxM2M1=
  - /M1/ and /M2/ are the actual text that matched the expressions in the parentheses
  - contents of parentheses can be any regex!

#+begin_src bash
echo pre ab123xx123xab post | grep --color '\(a[bc]\)\([0-9][0-9]*\)xx\2x\1'
echo pre ab123xx321xac post | grep --color '\(a[bc]\)\([0-9][0-9]*\)xx\2x\1'
#+end_src

#+RESULTS:
: pre ab123xx123xab post

+ up to 9 parenthesized subexpres are allowed

+ often termed "backreferences"

+ *BREs only*

** operator precedence
From heighest to lowest:
1. bracket symbols: =[:class:]=, =[=c=]=, =[.cs.]=
2. =\metachar=
3. bracket expressions
4. =\(...\)= and =\digit=
5. =*= and =\{...\}=
6. concatenation (=abc= is a followed by =b= followed by =c=)
7. =^= and =$= anchors

** longest, leftmost match
+ regexs match the longest possible, leftmost ocurrence of text that can match
+ the match ends at the first character that cannot be matched
+ if some text matched, that text is used, even if a longer match occurs later on the line
+ this matters when doing substitutions (replacing matched text with =sed=, =awk=, ...)

#+begin_src bash :results output verbatim
echo 123 eafg 123 youyou | sed 's/[aeiouy]*/X/'

# g for matching ALL
echo 123 eafg 123 youyou | sed 's/[aeiouy][aeiouy]*/X/g'
#+end_src

#+RESULTS:
: X123 eafg 123 youyou
: 123 Xfg 123 X
