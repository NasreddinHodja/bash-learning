#+title: Regular Expressions
#+index: 8
#+breadcrumbs: index:/index.html
#+back: << Simple Text Processing:/simple-text-processing.html
#+next: >> sed:/sed.html
#+source: https://youtu.be/fAgz66M4aNc?si=ybChoNNggXGZmo8U

* BREs
** Regular expression concepts
A regex is a language describing text to be matched

A regex is composed of:
+ *regular chars* that stand for themselves
+ *metachars* that stand for a regular expression
+ *expressions* denoting categories of chars or sub-parts of a regex

Historically, different tools used different regex "flavors"

POSIX standardizes 2 flavours.
Other tools enhances regexs beyond what we cover here

+ *Basic Regucal Expression (BRE)*
  - simpler to learn, less computationally expensive
+ *Extended Regucal Expression (*ERE)*
  - much more powerful, more expensive
  - on moern systems, no real difference in "expense"

What programs use regex?
+ The =grep= family
  - =grep= - BRE
  - =egrep= and =grep -E= - ERE
  - =fgrep= and =grep -F= - string matching in parallel
  - POSIX standardizing brings them all into the single =grep= command
+ =sed= - text matching and substitution
+ =awk= - pattern matching with programming
+ text editors: =ed=, =ex=, =vim=, =emacs=
+ scripting languages, usually with their on flavours

*** =grep= options
+ use =pat= as pattern: =-e pat=
+ read list of patterns from file: =-f file=
+ ignore case in input: =-i=
+ list matching input files: =-l=
+ print lines that don't match: =-v=
+ supress output ("quiet", exit status only): =-q=
  - often, you can use => /dev/null= instead (more obvious)
+ don't print errors ("silent"): =-s=

*** Robustness
+ invest time in learning regexs
+ use EREs wherever possible
+ *always quote your regexs on the shell command line*

** Basic regex components
*** single char expressions
+ reg chars, like "A" or "#" match themselves
+ case matters: "A" and "a" are different
+ period ("dot") matches any single char
  - may or may not match newline, program dependent
+ escaped metachar:
  - =\.= matches a real period
  - =\\= matches a real backslash

+ reg chars match themselves:
#+begin_src bash
# echo 'Hi there how are you' | grep --color=always 'how'
echo 'Hi there how are you' | grep -o 'how'
#+end_src

#+RESULTS:
: how

+ dot matches any single char:
#+begin_src bash :results output verbatim
echo tolstoy says im toldtoy | grep -o tol.toy
#+end_src

#+RESULTS:
: tolstoy
: toldtoy

*** bracket expressions
+ any one of a set: =[aeiouy]= matches /one/ Englis vowel
+ any not in a set: =[^aieouy]= matches a non-vowel
+ ranges: =[0-9]= -> a digit, =[a-z]= -> a lowercase letter
  - locale dependent (messy)
+ characted classes: digits, punctuation, letters, ...
  - classes: alnum, alpha, blank, cntrl, digit, graph, lower, print, punct, space, upper, digit

+ =grep= matches all ocurrences
#+begin_src bash :results output verbatim
echo 123 eafg | grep -o '[aeiouy]'
#+end_src

#+RESULTS:
: e
: a

Using =sed= to substitute, matches only the first:
#+begin_src bash
echo 123 eafg | sed 's/[aeiouy]/X/'
#+end_src

#+RESULTS:
: 123 Xafg

Complemented bracket expressions & char classes:
#+begin_src bash :results ouput verbatim
echo 123 eafg | grep -o '[^aeiouy]'
echo "---"
echo 123 eafg | grep -o '[[:digit:]]'
#+end_src

#+RESULTS:
#+begin_example
1
2
3

f
g
---
1
2
3
#+end_example


*** repetition - zero or more
Asterisk ("star") indicates zero or more of the preceding char

+ =ab*c= matches =ac=, =abc=, =abbc=,  =abbbc=, ...
+ zero of "x" does not mean one or more of "y"
+ =.*= matches any single char, 0 or more times (careful, *also matches null string*)

*** repetition - interval expressions
+ =c\{N\}= - /N/ occurrences of /c/
+ =c\{N,\}= - at least /N/ occurrences of /c/
+ =c\{N, M\}= - /N/ to /M/ occurrences of /c/ (/N/, /M/ up to =RE_DUP_MAX=)

Here /c/ means a single char as described earlier

*** achoring maches
+ cared ("up arrow", "hat", =^=) - match must start at beginning of line or string
+ dollar sign (=$=) - match must occur at end of line or string
+ =^= and =$= in the middle of a BRE stand for themselves

#+begin_src bash :results output verbatim
echo 123 you 123 | grep -o '^[[:digit:]]*'
echo "---"
echo 123 you 123 | grep -o '^[^[:digit:]]*'
echo "---"
echo 123 you 123 | grep -o '[^[:digit:]]*$'
#+end_src

#+RESULTS:
: 123
: ---
: ---

*** parenthasized subexpressions
+ =\(a[bc\)\(123\)xx\2\1= - same as =a[bc]123xxM2M1=
  - /M1/ and /M2/ are the actual text that matched the expressions in the parentheses
  - contents of parentheses can be any regex!

#+begin_src bash :results ouput verbatim
echo pre ab123xx123xab post | grep -o '\(a[bc]\)\([0-9][0-9]*\)xx\2x\1'
echo '---'
echo pre ab123xx321xac post | grep -o '\(a[bc]\)\([0-9][0-9]*\)xx\2x\1'
#+end_src

#+RESULTS:
: ab123xx123xab
: ---

+ up to 9 parenthesized subexpres are allowed

+ often termed "backreferences"

+ *BREs only*

*** operator precedence
From heighest to lowest:
1. bracket symbols: =[:class:]=, =[=c=]=, =[.cs.]=
2. =\metachar=
3. bracket expressions
4. =\(...\)= and =\digit=
5. =*= and =\{...\}=
6. concatenation (=abc= is a followed by =b= followed by =c=)
7. =^= and =$= anchors

*** longest, leftmost match
+ regexs match the longest possible, leftmost ocurrence of text that can match
+ the match ends at the first character that cannot be matched
+ if some text matched, that text is used, even if a longer match occurs later on the line
+ this matters when doing substitutions (replacing matched text with =sed=, =awk=, ...)

#+begin_src bash :results output verbatim
echo 123 eafg 123 youyou | sed 's/[aeiouy]*/X/'

# g for matching ALL
echo 123 eafg 123 youyou | sed 's/[aeiouy][aeiouy]*/X/g'
#+end_src

#+RESULTS:
: X123 eafg 123 youyou
: 123 Xfg 123 X

* EREs
** Regular expression concepts
A regex is a language describing text to be matched

A regex is composed of:
+ *regular chars* that stand for themselves
+ *metachars* that stand for a regular expression
+ *expressions* denoting categories of chars or sub-parts of a regex

Historically, different tools used different regex "flavors"

POSIX standardizes 2 flavours.
Other tools enhances regexs beyond what we cover here

+ *Basic Regucal Expression (BRE)*
  - simpler to learn, less computationally expensive
+ *Extended Regucal Expression (*ERE)*
  - much more powerful, more expensive
  - on moern systems, no real difference in "expense"

What programs use regex?
+ The =grep= family
  - =grep= - BRE
  - =egrep= and =grep -E= - ERE
  - =fgrep= and =grep -F= - string matching in parallel
  - POSIX standardizing brings them all into the single =grep= command
+ =sed= - text matching and substitution
+ =awk= - pattern matching with programming
+ text editors: =ed=, =ex=, =vim=, =emacs=
+ scripting languages, usually with their on flavours

*** =grep= options
+ use =pat= as pattern: =-e pat=
+ read list of patterns from file: =-f file=
+ ignore case in input: =-i=
+ list matching input files: =-l=
+ print lines that don't match: =-v=
+ supress output ("quiet", exit status only): =-q=
  - often, you can use => /dev/null= instead (more obvious)
+ don't print errors ("silent"): =-s=

*** Robustness
+ invest time in learning regexs
+ use EREs wherever possible
+ *always quote your regexs on the shell command line*

** Basic regex components
Same as BREs:
+ matching single chars
  - reg chars, "dot", escaped metachars
  - bracket expressions: ranges and classes
+ repetition with =*= and interval expression (={...}=)
+ anchoring with =^= and =$=
+ longest leftmost chars

** Aditional repetition operators
+ =re?= matches zero or one of =re= - "optional"
+ =re+= matches one or more of =re= - "at least one of"

Note that =re= can be more than 1 char...
+ applies to =*= and ={...}= also

#+begin_src bash :results output verbatim
echo ac abc abbc abbbc | grep -oE 'ab?c'
echo '---'
echo ac abc abbc abbbc | grep -oE 'ab+c'
#+end_src

#+RESULTS:
: ac
: abc
: ---
: abc
: abbc
: abbbc

** Grouping with parenthesis
Parentheses group smaller REs into larger ones.

+ =([[:digit:]]{3}-[[:digit:]]{4}_)+= is one or more US phone numbers ("_" marks space for presentation purposes)

#+begin_src bash :results output verbatim
echo abc 555-1212 555-2121 cba | grep -oE '([[:digit:]]{3}-[[:digit:]]{4} )+'
#+end_src

#+RESULTS:
: 555-1212 555-2121

+ *EREs do not have backreferences!*

+ here too, things get cryptic quickly. Read from the *outside in*

** Alternation
Separate alternatives with =|=

+ =(hello|hi)_world= matches =hello_world= and =hi_world=
+ often used with parenthesis, as shown above
+ lowest precedence of all operators
  - =^hello|hi$= -> =(^hello)|(hi$)=, not =^(hello|hi)$=
+ makes EREs much more expressive than BREs

#+begin_src bash :results output verbatim
echo 'hi there
hello there' | grep -oE 'hello|hi'
#+end_src

#+RESULTS:
: hi
: hello

#+begin_src bash :results output verbatim
echo 'hi there
hello there' | grep -oE '^hello|hi$'

echo '---'

echo 'hi there
hello there' | grep -oE '^(hello|hi)$'
#+end_src

#+RESULTS:
: hello
: ---

** ERE operator precedence
1. bracket symbols: =[:class:]=, =[=c=]=, =[.cs.]=
2. =\metacharacter=
3. bracket expressions
4. =(...)= grouping
5. =*= =+= =?= and ={...}=
6. concatenation
7. =^= and =$= anchors
8. alternation

** Robustness
+ always quote your REs
  - single quotes are much better than double
+ with great power comes great responsability...
  - pay more attention when using EREs

** Using plain grep
Without the =-E=

#+begin_src bash :results output verbatim
echo abc 555-1212 555-2121 cba | grep -o '\([[:digit:]]]\{3\}-[[:digit:]]\{4\} \)\+'

echo 'hello
hi
howdy' | grep -o '^\(hello\|hi\)$'
#+end_src

#+RESULTS:
: hello
: hi
